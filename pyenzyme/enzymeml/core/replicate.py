'''
File: replicate.py
Project: core
Author: Jan Range
License: BSD-2 clause
-----
Last Modified: Thursday July 15th 2021 1:00:51 am
Modified By: Jan Range (<jan.range@simtech.uni-stuttgart.de>)
-----
Copyright (c) 2021 Institute of Biochemistry and Technical Biochemistry Stuttgart
'''

from pydantic import Field, validator, PrivateAttr
from typing import TYPE_CHECKING, Optional
from enum import Enum
from dataclasses import dataclass

from pyenzyme.enzymeml.core.enzymemlbase import EnzymeMLBase
from pyenzyme.enzymeml.core.ontology import DataTypes
from pyenzyme.enzymeml.core.exceptions import DataError
from pyenzyme.enzymeml.core.utils import (
    type_checking,
    deprecated_getter
)

if TYPE_CHECKING:  # pragma: no cover
    static_check_init_args = dataclass
else:
    static_check_init_args = type_checking


@static_check_init_args
class Replicate(EnzymeMLBase):

    replicate_id: str = Field(
        ...,
        description="Unique identifier of the replicate",
    )

    reactant_id: str = Field(
        ...,
        description="Unique identifier of the reactant that has been measured.",
        regex=r"s[\d]+"
    )

    measurement_id: Optional[str] = Field(
        None,
        description="Unique identifier of the measurement that the replicate is part of.",
        regex=r"m[\d]+"
    )

    data_type: DataTypes = Field(
        DataTypes.CONCENTRATION,
        description="Type of data that was measured (e.g. concentration)",
    )

    data_unit: str = Field(
        ...,
        description="SI unit of the data that was measured.",
    )

    time_unit: str = Field(
        description="Time unit of the replicate.",
    )

    time: list[float] = Field(
        None,
        description="Time steps of the replicate.",
    )

    data: list[float] = Field(
        None,
        description="Data that was measured.",
    )

    is_calculated: bool = Field(
        False,
        description="Whether or not the data has been generated by simulation.",
    )

    uri: Optional[str] = Field(
        None,
        description="URI of the protein.",
    )

    creator_id: Optional[str] = Field(
        None,
        description="Unique identifier of the author.",
    )

    # * Private
    _time_unit_id: Optional[str] = PrivateAttr(None)
    _data_unit_id: Optional[str] = PrivateAttr(None)

    @validator("data")
    def check_data_completeness(cls, data: list[float], values: dict):
        if values.get("time") is None and data is not None:
            # Check if time is given
            raise DataError(
                "No time values provided for the data yet. \
                Please include time values too, using the 'time' attribute"
            )
        elif values.get("time"):
            # Check if the data complies with the time values
            timesteps = len(values["time"])
            if timesteps != len(data):
                raise DataError(
                    f"The number of steps provided for the data [{len(data)}] does not match the number of timesteps [{timesteps}]"
                )

        return data

    @deprecated_getter("measurement_id")
    def getMeasurement(self):
        return self.measurement_id

    @deprecated_getter("is_calculated")
    def getIsCalculated(self):
        return self.is_calculated

    @deprecated_getter("replicate_id")
    def getReplica(self):
        return self.replicate_id

    @deprecated_getter("reactant_id")
    def getReactant(self):
        return self.reactant_id

    @deprecated_getter("data_type")
    def getType(self):
        return self.data_type

    @deprecated_getter("data_unit")
    def getDataUnit(self):
        return self.data_unit

    @deprecated_getter("time_unit")
    def getTimeUnit(self):
        return self.time_unit

    @deprecated_getter("time' and 'data")
    def getData(self, sep=False):
        return self.time, self.data
